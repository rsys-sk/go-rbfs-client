/*
 * RBFS Operational State API
 *
 * This contract describes the RBFS Operational State API contract defined by RBMS, the RtBrick Management System. This API is a _consumer-driven_ API, which means that all changes to this API **must be approved** by RBMS, the consumer of this API to avoid compatibility issues.  The API is kept backwards-compatible and anyone is allowed to _use_ this API.  The consumer of the API _must_ ignore additional attributes not explained in this specification. Additional attributes are _not_ considered violating backwards compatibility. In contrary, additional attributes allow extending the API while preserving backward compatibility.
 *
 * API version: 1.0.0
 * Contact: martin@rtbrick.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package state

import (
	"context"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type StreamsApiService service

/*
StreamsApiService Pings the given destination IP address.
Pings the given destination from the specified source IP or source IFL with the provided settings and streams the ping output line-by-line in plain text to the caller.  Three options exist to specify the ping destination:  1. Use &#x60;destination_ip&#x60; to specify the destination IP address in IPv6 or IPv4 format. 2. Use &#x60;destination_aaaa&#x60; to query the DNS for an AAAA record for the specified host name. 3. Use &#x60;destination_a&#x60; to query the DNS for an A record for the specified host name.  The precedence is in the above ordering if multiple destinations are specified. An error is returned if no destination is specified.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *StreamsApiStreamPingOpts - Optional Parameters:
     * @param "DestinationIp" (optional.String) -  Destination IPv4 or IPv6 address
     * @param "DestinationAaaa" (optional.String) -  Destination hostname to query DNS for an AAAA record (IPv6 address)
     * @param "DestinationA" (optional.String) -  Destination hostname to query DNS for an A record (IPv4 address)
     * @param "SourceIp" (optional.String) -  Source IPv4 or IPv6 address
     * @param "SourceIfl" (optional.String) -  Source interface name.
     * @param "InstanceName" (optional.String) -  Routing instance name
     * @param "Count" (optional.Int32) -  Number of pings.
     * @param "Interval" (optional.Float32) -  Ping interval in seconds.
     * @param "Size" (optional.Int32) -  Packet payload size in bytes.
     * @param "Ttl" (optional.Int32) -  IP TTL value
@return string
*/

type StreamsApiStreamPingOpts struct {
	DestinationIp   optional.String
	DestinationAaaa optional.String
	DestinationA    optional.String
	SourceIp        optional.String
	SourceIfl       optional.String
	InstanceName    optional.String
	Count           optional.Int32
	Interval        optional.Float32
	Size            optional.Int32
	Ttl             optional.Int32
}

func (a *StreamsApiService) StreamPing(ctx context.Context, localVarOptionals *StreamsApiStreamPingOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/streams/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DestinationIp.IsSet() {
		localVarQueryParams.Add("destination_ip", parameterToString(localVarOptionals.DestinationIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationAaaa.IsSet() {
		localVarQueryParams.Add("destination_aaaa", parameterToString(localVarOptionals.DestinationAaaa.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationA.IsSet() {
		localVarQueryParams.Add("destination_a", parameterToString(localVarOptionals.DestinationA.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIp.IsSet() {
		localVarQueryParams.Add("source_ip", parameterToString(localVarOptionals.SourceIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIfl.IsSet() {
		localVarQueryParams.Add("source_ifl", parameterToString(localVarOptionals.SourceIfl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstanceName.IsSet() {
		localVarQueryParams.Add("instance_name", parameterToString(localVarOptionals.InstanceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Interval.IsSet() {
		localVarQueryParams.Add("interval", parameterToString(localVarOptionals.Interval.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ttl.IsSet() {
		localVarQueryParams.Add("ttl", parameterToString(localVarOptionals.Ttl.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
StreamsApiService Traces the route to the given destination IP address.
Traces the route to the given destination from the specified source IP or source IFL with the provided settings and streams the traceroute output line-by-line in plain text to the caller.  Three options exist to specify the traceroute destination:  1. Use &#x60;destination_ip&#x60; to specify the destination IP address in IPv6 or IPv4 format. 2. Use &#x60;destination_aaaa&#x60; to query the DNS for an AAAA record for the specified host name. 3. Use &#x60;destination_a&#x60; to query the DNS for an A record for the specified host name.  The precedence is in the above ordering if multiple destinations are specified. An error is returned if no destination is specified.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *StreamsApiStreamTracerouteOpts - Optional Parameters:
     * @param "DestinationIp" (optional.String) -  Destination IPv4 or IPv6 address
     * @param "DestinationAaaa" (optional.String) -  Destination hostname to query DNS for an AAAA record (IPv6 address)
     * @param "DestinationA" (optional.String) -  Destination hostname to query DNS for an A record (IPv4 address)
     * @param "SourceIp" (optional.String) -  Source IPv4 or IPv6 address
     * @param "SourceIfl" (optional.String) -  Source interface name.
     * @param "InstanceName" (optional.String) -  Routing instance name
     * @param "MaxHops" (optional.Int32) -  Maximum number of acceptable hops to reach the given destination.
     * @param "Size" (optional.Int32) -  Packet payload size in bytes.
     * @param "Interval" (optional.Float32) -  Ping interval in seconds.
@return string
*/

type StreamsApiStreamTracerouteOpts struct {
	DestinationIp   optional.String
	DestinationAaaa optional.String
	DestinationA    optional.String
	SourceIp        optional.String
	SourceIfl       optional.String
	InstanceName    optional.String
	MaxHops         optional.Int32
	Size            optional.Int32
	Interval        optional.Float32
}

func (a *StreamsApiService) StreamTraceroute(ctx context.Context, localVarOptionals *StreamsApiStreamTracerouteOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/streams/traceroute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DestinationIp.IsSet() {
		localVarQueryParams.Add("destination_ip", parameterToString(localVarOptionals.DestinationIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationAaaa.IsSet() {
		localVarQueryParams.Add("destination_aaaa", parameterToString(localVarOptionals.DestinationAaaa.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationA.IsSet() {
		localVarQueryParams.Add("destination_a", parameterToString(localVarOptionals.DestinationA.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIp.IsSet() {
		localVarQueryParams.Add("source_ip", parameterToString(localVarOptionals.SourceIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIfl.IsSet() {
		localVarQueryParams.Add("source_ifl", parameterToString(localVarOptionals.SourceIfl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstanceName.IsSet() {
		localVarQueryParams.Add("instance_name", parameterToString(localVarOptionals.InstanceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHops.IsSet() {
		localVarQueryParams.Add("max_hops", parameterToString(localVarOptionals.MaxHops.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Interval.IsSet() {
		localVarQueryParams.Add("interval", parameterToString(localVarOptionals.Interval.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
