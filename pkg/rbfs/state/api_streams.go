/*
 * RBFS Operational State API
 *
 * This contract describes the RBFS Operational State API contract defined by RBMS, the RtBrick Management System. This API is a _consumer-driven_ API, which means that all changes to this API **must be approved** by RBMS, the consumer of this API to avoid compatibility issues.  The API is kept backwards-compatible and anyone is allowed to _use_ this API.  The consumer of the API _must_ ignore additional attributes not explained in this specification. Additional attributes are _not_ considered violating backwards compatibility. In contrary, additional attributes allow extending the API while preserving backward compatibility.
 *
 * API version: 1.0.0
 * Contact: martin@rtbrick.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package state

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type StreamsApiService service

/*
StreamsApiService Pings the given destination IP address (ICMP ping).
Pings the given destination from the specified source IP or source IFL with the provided settings and streams the ping output line-by-line in plain text to the caller (ICMP ping).  Three options exist to specify the ping destination:  1. Use &#x60;destination_ip&#x60; to specify the destination IP address in IPv6 or IPv4 format. 2. Use &#x60;destination_aaaa&#x60; to query the DNS for an AAAA record for the specified host name. 3. Use &#x60;destination_a&#x60; to query the DNS for an A record for the specified host name.  The precedence is in the above ordering if multiple destinations are specified. An error is returned if no destination is specified.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *StreamsApiStreamPingOpts - Optional Parameters:
     * @param "DestinationIp" (optional.String) -  Destination IPv4 or IPv6 address
     * @param "DestinationAaaa" (optional.String) -  Destination hostname to query DNS for an AAAA record (IPv6 address)
     * @param "DestinationA" (optional.String) -  Destination hostname to query DNS for an A record (IPv4 address)
     * @param "SourceIp" (optional.String) -  Source IPv4 or IPv6 address
     * @param "SourceIfl" (optional.String) -  Source interface name.
     * @param "InstanceName" (optional.String) -  Routing instance name
     * @param "Count" (optional.Int) -  Number of pings.
     * @param "Interval" (optional.Float32) -  Ping interval in seconds.
     * @param "Size" (optional.Int) -  Packet payload size in bytes.
     * @param "Ttl" (optional.Int) -  IP TTL value
     * @param "Tos" (optional.Int) -  IP ToS value
@return string
*/

type StreamsApiStreamPingOpts struct {
	DestinationIp   optional.String
	DestinationAaaa optional.String
	DestinationA    optional.String
	SourceIp        optional.String
	SourceIfl       optional.String
	InstanceName    optional.String
	Count           optional.Int
	Interval        optional.Float32
	Size            optional.Int
	Ttl             optional.Int
	Tos             optional.Int
}

func (a *StreamsApiService) StreamPing(ctx context.Context, localVarOptionals *StreamsApiStreamPingOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/streams/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DestinationIp.IsSet() {
		localVarQueryParams.Add("destination_ip", parameterToString(localVarOptionals.DestinationIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationAaaa.IsSet() {
		localVarQueryParams.Add("destination_aaaa", parameterToString(localVarOptionals.DestinationAaaa.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationA.IsSet() {
		localVarQueryParams.Add("destination_a", parameterToString(localVarOptionals.DestinationA.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIp.IsSet() {
		localVarQueryParams.Add("source_ip", parameterToString(localVarOptionals.SourceIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIfl.IsSet() {
		localVarQueryParams.Add("source_ifl", parameterToString(localVarOptionals.SourceIfl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstanceName.IsSet() {
		localVarQueryParams.Add("instance_name", parameterToString(localVarOptionals.InstanceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Interval.IsSet() {
		localVarQueryParams.Add("interval", parameterToString(localVarOptionals.Interval.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ttl.IsSet() {
		localVarQueryParams.Add("ttl", parameterToString(localVarOptionals.Ttl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tos.IsSet() {
		localVarQueryParams.Add("tos", parameterToString(localVarOptionals.Tos.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
StreamsApiService Pings the given destination (LSPING).
Pings the given destination FEC from the specified source IP with the provided settings (LSPING).  Three options exist to specify the ping destination:  1. Use &#x60;destination_ip_fec&#x60; to specify the destination FEC in IPv6 or IPv4 CIDR format. 2. Use &#x60;destination_aaaa&#x60; to query the DNS for an AAAA record for the specified hostname. The hostprefix will be used as FEC. 3. Use &#x60;destination_a&#x60; to query the DNS for an A record for the specified hostname. The hostprefix will be uses as FEC.  The precedence is in the above ordering if multiple destinations are specified. An error is returned if no destination is specified.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *StreamsApiStreamPingMplsOpts - Optional Parameters:
     * @param "FecType" (optional.String) -  The FEC type.
     * @param "DestinationIpFec" (optional.String) -  Destination FEC in CIDR notion.
     * @param "DestinationAaaa" (optional.String) -  Destination hostname to query DNS for an AAAA record (IPv6 host prefix)
     * @param "DestinationA" (optional.String) -  Destination hostname to query DNS for an A record (IPv4 host prefix)
     * @param "SourceIp" (optional.String) -  Source IPv4 or IPv6 address
     * @param "InstanceName" (optional.String) -  Routing instance name
     * @param "Count" (optional.Int) -  Number of pings.
     * @param "Interval" (optional.Float64) -  Ping interval in seconds.
     * @param "Size" (optional.Int) -  Packet payload size in bytes.
@return string
*/

type StreamsApiStreamPingMplsOpts struct {
	FecType          optional.String
	DestinationIpFec optional.String
	DestinationAaaa  optional.String
	DestinationA     optional.String
	SourceIp         optional.String
	InstanceName     optional.String
	Count            optional.Int
	Interval         optional.Float64
	Size             optional.Int
}

func (a *StreamsApiService) StreamPingMpls(ctx context.Context, localVarOptionals *StreamsApiStreamPingMplsOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/streams/ping-mpls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.FecType.IsSet() {
		localVarQueryParams.Add("fec_type", parameterToString(localVarOptionals.FecType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationIpFec.IsSet() {
		localVarQueryParams.Add("destination_ip_fec", parameterToString(localVarOptionals.DestinationIpFec.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationAaaa.IsSet() {
		localVarQueryParams.Add("destination_aaaa", parameterToString(localVarOptionals.DestinationAaaa.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationA.IsSet() {
		localVarQueryParams.Add("destination_a", parameterToString(localVarOptionals.DestinationA.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIp.IsSet() {
		localVarQueryParams.Add("source_ip", parameterToString(localVarOptionals.SourceIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstanceName.IsSet() {
		localVarQueryParams.Add("instance_name", parameterToString(localVarOptionals.InstanceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Interval.IsSet() {
		localVarQueryParams.Add("interval", parameterToString(localVarOptionals.Interval.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
StreamsApiService Traces the route to the given destination IP address.
Traces the route to the given destination from the specified source IP or source IFL with the provided settings and streams the traceroute output line-by-line in plain text to the caller.  Three options exist to specify the traceroute destination:  1. Use &#x60;destination_ip&#x60; to specify the destination IP address in IPv6 or IPv4 format. 2. Use &#x60;destination_aaaa&#x60; to query the DNS for an AAAA record for the specified host name. 3. Use &#x60;destination_a&#x60; to query the DNS for an A record for the specified host name.  The precedence is in the above ordering if multiple destinations are specified. An error is returned if no destination is specified.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *StreamsApiStreamTracerouteOpts - Optional Parameters:
     * @param "DestinationIp" (optional.String) -  Destination IPv4 or IPv6 address
     * @param "DestinationAaaa" (optional.String) -  Destination hostname to query DNS for an AAAA record (IPv6 address)
     * @param "DestinationA" (optional.String) -  Destination hostname to query DNS for an A record (IPv4 address)
     * @param "SourceIp" (optional.String) -  Source IPv4 or IPv6 address
     * @param "SourceIfl" (optional.String) -  Source interface name.
     * @param "InstanceName" (optional.String) -  Routing instance name
     * @param "MaxHops" (optional.Int) -  Maximum number of acceptable hops to reach the given destination.
     * @param "Size" (optional.Int) -  Packet payload size in bytes.
     * @param "Interval" (optional.Float32) -  Ping interval in seconds.
@return string
*/

type StreamsApiStreamTracerouteOpts struct {
	DestinationIp   optional.String
	DestinationAaaa optional.String
	DestinationA    optional.String
	SourceIp        optional.String
	SourceIfl       optional.String
	InstanceName    optional.String
	MaxHops         optional.Int
	Size            optional.Int
	Interval        optional.Float32
}

func (a *StreamsApiService) StreamTraceroute(ctx context.Context, localVarOptionals *StreamsApiStreamTracerouteOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/streams/traceroute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DestinationIp.IsSet() {
		localVarQueryParams.Add("destination_ip", parameterToString(localVarOptionals.DestinationIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationAaaa.IsSet() {
		localVarQueryParams.Add("destination_aaaa", parameterToString(localVarOptionals.DestinationAaaa.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationA.IsSet() {
		localVarQueryParams.Add("destination_a", parameterToString(localVarOptionals.DestinationA.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIp.IsSet() {
		localVarQueryParams.Add("source_ip", parameterToString(localVarOptionals.SourceIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIfl.IsSet() {
		localVarQueryParams.Add("source_ifl", parameterToString(localVarOptionals.SourceIfl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstanceName.IsSet() {
		localVarQueryParams.Add("instance_name", parameterToString(localVarOptionals.InstanceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHops.IsSet() {
		localVarQueryParams.Add("max_hops", parameterToString(localVarOptionals.MaxHops.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Interval.IsSet() {
		localVarQueryParams.Add("interval", parameterToString(localVarOptionals.Interval.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
