/*
 * RBFS Operational State API
 *
 * This contract describes the RBFS Operational State API contract defined by RBMS, the RtBrick Management System. This API is a _consumer-driven_ API, which means that all changes to this API **must be approved** by RBMS, the consumer of this API to avoid compatibility issues.  The API is kept backwards-compatible and anyone is allowed to _use_ this API.  The consumer of the API _must_ ignore additional attributes not explained in this specification. Additional attributes are _not_ considered violating backwards compatibility. In contrary, additional attributes allow extending the API while preserving backward compatibility.
 *
 * API version: 1.0.0
 * Contact: martin@rtbrick.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package state

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type SubscriberApiService service

/*
SubscriberApiService Adds test subscribers.
Injects test subscribers into the Test AAA request table.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body List of subscriber attribute objects.
*/
func (a *SubscriberApiService) AddTestSubscribers(ctx context.Context, body []TestAaaObject) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/test-aaa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SubscriberApiService Terminates the L2BSA subscriber session.
Trigger the asynchronous subscribers termination.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param ifpName The physical interface name.
  - @param anp The ANP VLAN ID.
*/
func (a *SubscriberApiService) ClearL2BSASubscriber(ctx context.Context, ifpName string, anp int) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/l2bsa/{ifp_name}/{anp}"
	localVarPath = strings.Replace(localVarPath, "{"+"ifp_name"+"}", fmt.Sprintf("%v", ifpName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"anp"+"}", fmt.Sprintf("%v", anp), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if anp < 1 {
		return nil, reportError("anp must be greater than 1")
	}
	if anp > 4094 {
		return nil, reportError("anp must be less than 4094")
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SubscriberApiService Terminates the subscriber session.
Trigger the asynchronous subscribers termination and  disconnect corresponding sessions.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subscriberId The subscriber ID.
 * @param optional nil or *SubscriberApiClearSubscriberOpts - Optional Parameters:
     * @param "Force" (optional.Bool) -  Forces subscriber session termination.

*/

type SubscriberApiClearSubscriberOpts struct {
	Force optional.Bool
}

func (a *SubscriberApiService) ClearSubscriber(ctx context.Context, subscriberId int, localVarOptionals *SubscriberApiClearSubscriberOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/{subscriber_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_id"+"}", fmt.Sprintf("%v", subscriberId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Force.IsSet() {
		localVarQueryParams.Add("force", parameterToString(localVarOptionals.Force.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SubscriberApiService Terminates all matching subscriber sessions.
Terminates all matching active subscriber sessions.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SubscriberApiClearSubscribersOpts - Optional Parameters:
     * @param "IfpName" (optional.String) -  The physical interface name.
     * @param "IflName" (optional.String) -  The name of the subscriber&#x27;s logical interface.
     * @param "OuterVlan" (optional.Int) -  Outer VLAN tag.
     * @param "AnpVlan" (optional.Int) -  ANP VLAN tag (for L2BSA subscribers).
     * @param "InnerVlan" (optional.Int) -  Inner VLAN tag.
     * @param "SubscriberId" (optional.Interface of int) -  A unique subscriber ID
     * @param "AccountingSessionId" (optional.String) -  The accounting session ID of the subscriber session.
     * @param "SubscriberUserName" (optional.String) -  The subscriber user name of the subscriber session.
     * @param "SubscriberUserNameMatches" (optional.String) -  Regular expression the subscriber user name must match.
     * @param "AgentRemoteId" (optional.String) -  The agent remote ID of the subscriber sessions.
     * @param "AgentRemoteIdMatches" (optional.String) -  Regular expression the agent remote ID must match.
     * @param "AgentCircuitId" (optional.String) -  The agent circuit ID of the subscriber sessions.
     * @param "AgentCircuitIdMatches" (optional.String) -  Regular expression the agent circuit ID must match.
     * @param "AccessType" (optional.Interface of SubscriberAccessType) -

*/

type SubscriberApiClearSubscribersOpts struct {
	IfpName                   optional.String
	IflName                   optional.String
	OuterVlan                 optional.Int
	AnpVlan                   optional.Int
	InnerVlan                 optional.Int
	SubscriberId              optional.Interface
	AccountingSessionId       optional.String
	SubscriberUserName        optional.String
	SubscriberUserNameMatches optional.String
	AgentRemoteId             optional.String
	AgentRemoteIdMatches      optional.String
	AgentCircuitId            optional.String
	AgentCircuitIdMatches     optional.String
	AccessType                optional.Interface
}

func (a *SubscriberApiService) ClearSubscribers(ctx context.Context, localVarOptionals *SubscriberApiClearSubscribersOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/terminate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IfpName.IsSet() {
		localVarQueryParams.Add("ifp_name", parameterToString(localVarOptionals.IfpName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IflName.IsSet() {
		localVarQueryParams.Add("ifl_name", parameterToString(localVarOptionals.IflName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OuterVlan.IsSet() {
		localVarQueryParams.Add("outer_vlan", parameterToString(localVarOptionals.OuterVlan.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AnpVlan.IsSet() {
		localVarQueryParams.Add("anp_vlan", parameterToString(localVarOptionals.AnpVlan.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InnerVlan.IsSet() {
		localVarQueryParams.Add("inner_vlan", parameterToString(localVarOptionals.InnerVlan.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubscriberId.IsSet() {
		localVarQueryParams.Add("subscriber_id", parameterToString(localVarOptionals.SubscriberId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountingSessionId.IsSet() {
		localVarQueryParams.Add("accounting_session_id", parameterToString(localVarOptionals.AccountingSessionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubscriberUserName.IsSet() {
		localVarQueryParams.Add("subscriber_user_name", parameterToString(localVarOptionals.SubscriberUserName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubscriberUserNameMatches.IsSet() {
		localVarQueryParams.Add("subscriber_user_name_matches", parameterToString(localVarOptionals.SubscriberUserNameMatches.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AgentRemoteId.IsSet() {
		localVarQueryParams.Add("agent_remote_id", parameterToString(localVarOptionals.AgentRemoteId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AgentRemoteIdMatches.IsSet() {
		localVarQueryParams.Add("agent_remote_id_matches", parameterToString(localVarOptionals.AgentRemoteIdMatches.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AgentCircuitId.IsSet() {
		localVarQueryParams.Add("agent_circuit_id", parameterToString(localVarOptionals.AgentCircuitId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AgentCircuitIdMatches.IsSet() {
		localVarQueryParams.Add("agent_circuit_id_matches", parameterToString(localVarOptionals.AgentCircuitIdMatches.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccessType.IsSet() {
		localVarQueryParams.Add("access_type", parameterToString(localVarOptionals.AccessType.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SubscriberApiService Disables lawful interception for the specified subscriber.
Disables lawful interception (LI) for the specified subscriber  with the specified mediation device, direction and LI identifier.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param subscriberId The subscriber ID.
  - @param id The LI request ID.
*/
func (a *SubscriberApiService) DisableLawfulInterceptionSubscriber(ctx context.Context, subscriberId int, id int) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/{subscriber_id}/disableLI"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_id"+"}", fmt.Sprintf("%v", subscriberId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if id < 1 {
		return nil, reportError("id must be greater than 1")
	}
	if id > 4194303 {
		return nil, reportError("id must be less than 4194303")
	}

	localVarQueryParams.Add("id", parameterToString(id, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SubscriberApiService Enables lawful interception for the specified subscriber.
Enables lawful interception (LI) for the specified subscriber  with the specified mediation device, direction and LI identifier.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param subscriberId The subscriber ID.
  - @param id The LI request ID.
  - @param direction The direction of traffic being intercepted.
  - @param medIp Mediation device IP address.
  - @param medPort Meditation device port.
  - @param medInstance Meditation device routing instance name.
*/
func (a *SubscriberApiService) EnableLawfulInterceptionSubscriber(ctx context.Context, subscriberId int, id int, direction string, medIp string, medPort int, medInstance string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/{subscriber_id}/enableLI"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_id"+"}", fmt.Sprintf("%v", subscriberId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if id < 1 {
		return nil, reportError("id must be greater than 1")
	}
	if id > 4194303 {
		return nil, reportError("id must be less than 4194303")
	}
	if medPort < 49152 {
		return nil, reportError("medPort must be greater than 49152")
	}
	if medPort > 65535 {
		return nil, reportError("medPort must be less than 65535")
	}

	localVarQueryParams.Add("id", parameterToString(id, ""))
	localVarQueryParams.Add("direction", parameterToString(direction, ""))
	localVarQueryParams.Add("med_ip", parameterToString(medIp, ""))
	localVarQueryParams.Add("med_port", parameterToString(medPort, ""))
	localVarQueryParams.Add("med_instance", parameterToString(medInstance, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SubscriberApiService Returns access line information.
Returns the access line information for the given subscriber.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param subscriberId The subscriber ID.

@return AccessLineInfo
*/
func (a *SubscriberApiService) GetAccessLineInfo(ctx context.Context, subscriberId int) (AccessLineInfo, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue AccessLineInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/{subscriber_id}/access-line-info"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_id"+"}", fmt.Sprintf("%v", subscriberId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v AccessLineInfo
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SubscriberApiService Returns adjusted accounting counter values.
Computes the adjusted accounting counter values for a given subscriber.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param subscriberId The subscriber ID.

@return SubscriberAdjustedAccounting
*/
func (a *SubscriberApiService) GetAjdustedAccountingValues(ctx context.Context, subscriberId int) (SubscriberAdjustedAccounting, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SubscriberAdjustedAccounting
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/{subscriber_id}/adjusted-accounting"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_id"+"}", fmt.Sprintf("%v", subscriberId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SubscriberAdjustedAccounting
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SubscriberApiService Returns the subscriber session statistics for a physical interface.
Returns the number of subscriber sessions grouped by access type (IPoE, PPPoE, L2TP, L2BSA and test),  the session state (setup, established, terminating) as well as the total session count grouped by the session state.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param ifpName The physical interface name.

@return IfpSubscriberSessionStatistics
*/
func (a *SubscriberApiService) GetIfpSubscriberSessionStatistics(ctx context.Context, ifpName string) (IfpSubscriberSessionStatistics, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue IfpSubscriberSessionStatistics
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/statistics/{ifp_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"ifp_name"+"}", fmt.Sprintf("%v", ifpName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v IfpSubscriberSessionStatistics
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SubscriberApiService Shows L2BSA subscriber session details.
Provides L2BSA subscriber details including accounting information,  logical interface information, VLAN information, physical interface  information, and access line information.  This commands returns the same output as &#x60;GET /subscribers/{subscriber_id}&#x60; just with a different key using interface name and ANP VLAN ID instead of subscriber ID.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param ifpName The physical interface name.
  - @param anp The ANP VLAN ID.

@return SubscriberSession
*/
func (a *SubscriberApiService) GetL2BSASubscriber(ctx context.Context, ifpName string, anp int) (SubscriberSession, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SubscriberSession
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/l2bsa/{ifp_name}/{anp}"
	localVarPath = strings.Replace(localVarPath, "{"+"ifp_name"+"}", fmt.Sprintf("%v", ifpName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"anp"+"}", fmt.Sprintf("%v", anp), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if anp < 1 {
		return localVarReturnValue, nil, reportError("anp must be greater than 1")
	}
	if anp > 4094 {
		return localVarReturnValue, nil, reportError("anp must be less than 4094")
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SubscriberSession
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SubscriberApiService Get adjusted accounting counter values.
Computes the adjusted accounting counter values for a given L2BSA subscriber.  This commands returns the same output as &#x60;GET /subscribers/{subscriber_id}/adjusted-accounting&#x60; just with a different key using interface name and ANP VLAN ID instead of subscriber ID.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param ifpName The physical interface name.
  - @param anp The ANP VLAN ID.

@return SubscriberAdjustedAccounting
*/
func (a *SubscriberApiService) GetL2BSASubscriberAdjustedAccountingValues(ctx context.Context, ifpName string, anp int) (SubscriberAdjustedAccounting, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SubscriberAdjustedAccounting
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/l2bsa/{ifp_name}/{anp}/adjusted-accounting"
	localVarPath = strings.Replace(localVarPath, "{"+"ifp_name"+"}", fmt.Sprintf("%v", ifpName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"anp"+"}", fmt.Sprintf("%v", anp), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if anp < 1 {
		return localVarReturnValue, nil, reportError("anp must be greater than 1")
	}
	if anp > 4094 {
		return localVarReturnValue, nil, reportError("anp must be less than 4094")
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SubscriberAdjustedAccounting
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SubscriberApiService Shows subscriber session details.
Provides subscriber session details including accounting information,  logical interface information, VLAN information, L2TP or PPPoE session  information, physical interface information, and access line information.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param subscriberId The subscriber ID.

@return SubscriberSession
*/
func (a *SubscriberApiService) GetSubscriber(ctx context.Context, subscriberId int) (SubscriberSession, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SubscriberSession
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/{subscriber_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_id"+"}", fmt.Sprintf("%v", subscriberId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SubscriberSession
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SubscriberApiService Lists the subscriber history.
Lists the subscriber history to examine why subscribers got disconnected in the past 24 hours. Returns all history entries matching the given filter.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SubscriberApiGetSubscriberHistoryOpts - Optional Parameters:
     * @param "SubscriberUserName" (optional.String) -  Filter for subscribers with the given user name.
     * @param "SubscriberUserNameMatches" (optional.String) -  Filter for subsribers matching the given user name pattern.
     * @param "IfpName" (optional.String) -  Filter for subscribers terminated on the specified physical interface.
     * @param "InnerVlan" (optional.Int) -  Filter for subscribers with the specified inner VLAN.
     * @param "OuterVlan" (optional.Int) -  Filter for subscribers terminated with the specified outer VLAN.
     * @param "SubscriberId" (optional.Float64) -  Filter for subscriber with the specified subscriber ID.
     * @param "AccessType" (optional.String) -  Filter for subscribers with the specified access type.
     * @param "AgentRemoteId" (optional.String) -  Filter for subscribers with the specified agent remote ID.
     * @param "AgentRemoteIdMatches" (optional.String) -  Filter for subscribers with agent remote IDs matching the given pattern.
     * @param "AgentCircuitId" (optional.String) -  Filter for subscribers with the specified agent circuit ID.
     * @param "AgentCircuitIdMatches" (optional.String) -  Filter for subscribers with agent circuit IDs matching the given pattern.
@return []SubscriberHistory
*/

type SubscriberApiGetSubscriberHistoryOpts struct {
	SubscriberUserName        optional.String
	SubscriberUserNameMatches optional.String
	IfpName                   optional.String
	InnerVlan                 optional.Int
	OuterVlan                 optional.Int
	SubscriberId              optional.Float64
	AccessType                optional.String
	AgentRemoteId             optional.String
	AgentRemoteIdMatches      optional.String
	AgentCircuitId            optional.String
	AgentCircuitIdMatches     optional.String
}

func (a *SubscriberApiService) GetSubscriberHistory(ctx context.Context, localVarOptionals *SubscriberApiGetSubscriberHistoryOpts) ([]SubscriberHistory, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []SubscriberHistory
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SubscriberUserName.IsSet() {
		localVarQueryParams.Add("subscriber_user_name", parameterToString(localVarOptionals.SubscriberUserName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubscriberUserNameMatches.IsSet() {
		localVarQueryParams.Add("subscriber_user_name_matches", parameterToString(localVarOptionals.SubscriberUserNameMatches.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IfpName.IsSet() {
		localVarQueryParams.Add("ifp_name", parameterToString(localVarOptionals.IfpName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InnerVlan.IsSet() {
		localVarQueryParams.Add("inner_vlan", parameterToString(localVarOptionals.InnerVlan.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OuterVlan.IsSet() {
		localVarQueryParams.Add("outer_vlan", parameterToString(localVarOptionals.OuterVlan.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubscriberId.IsSet() {
		localVarQueryParams.Add("subscriber_id", parameterToString(localVarOptionals.SubscriberId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccessType.IsSet() {
		localVarQueryParams.Add("access_type", parameterToString(localVarOptionals.AccessType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AgentRemoteId.IsSet() {
		localVarQueryParams.Add("agent_remote_id", parameterToString(localVarOptionals.AgentRemoteId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AgentRemoteIdMatches.IsSet() {
		localVarQueryParams.Add("agent_remote_id_matches", parameterToString(localVarOptionals.AgentRemoteIdMatches.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AgentCircuitId.IsSet() {
		localVarQueryParams.Add("agent_circuit_id", parameterToString(localVarOptionals.AgentCircuitId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AgentCircuitIdMatches.IsSet() {
		localVarQueryParams.Add("agent_circuit_id_matches", parameterToString(localVarOptionals.AgentCircuitIdMatches.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []SubscriberHistory
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SubscriberApiService Returns the subscriber session summary statistics.
Returns the number of subscriber sessions grouped by the access type (IPoE, PPPoE, L2TP, L2BSA and test),  the session state (setup, established, terminating) and the physical interface as well as aggregated counts. The aggregated counts include the total number of sessions per physical interface and state as well as  the number of sessions per access type and state, and the total session count per state for the entire switch.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return SubscriberSessionStatistics
*/
func (a *SubscriberApiService) GetSubscriberSessionStatistics(ctx context.Context) (SubscriberSessionStatistics, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue SubscriberSessionStatistics
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/statistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v SubscriberSessionStatistics
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SubscriberApiService Lists all matching subscriber sessions.
Lists all matching active subscriber sessions.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SubscriberApiGetSubscribersOpts - Optional Parameters:
     * @param "IfpName" (optional.String) -  The physical interface name.
     * @param "IflName" (optional.String) -  The name of the subscriber&#x27;s logical interface.
     * @param "OuterVlan" (optional.Int) -  The outer VLAN tag.
     * @param "AnpVlan" (optional.Int) -  The ANP-VLAN ID (for L2BSA subscribers).
     * @param "InnerVlan" (optional.Int) -  The inner VLAN tag.
     * @param "SubscriberId" (optional.Interface of int) -  The unique subscriber ID.
     * @param "AccountingSessionId" (optional.String) -  The accounting session ID of the subscriber session.
     * @param "SubscriberUserName" (optional.String) -  The subscriber&#x27;s user name.
     * @param "SubscriberUserNameMatches" (optional.String) -  Regular expression the subscriber user name must match.
     * @param "AgentRemoteId" (optional.String) -  The agent remote ID of the subscriber session.
     * @param "AgentRemoteIdMatches" (optional.String) -  Regular expression the agent remote ID must match.
     * @param "AgentCircuitId" (optional.String) -  The agent circuit ID of the subscriber session.
     * @param "AgentCircuitIdMatches" (optional.String) -  Regular expression the agent circuit ID must match.
     * @param "AccessType" (optional.Interface of SubscriberAccessType) -  The access type of the subscriber session.
     * @param "Limit" (optional.Int) -  Limits the number of returned subscriber sessions to the given value.
     * @param "Cursor" (optional.String) -  Starts reading subscriber sessions from the given subscriber ID.
@return []SubscriberSessionRef
*/

type SubscriberApiGetSubscribersOpts struct {
	IfpName                   optional.String
	IflName                   optional.String
	OuterVlan                 optional.Int
	AnpVlan                   optional.Int
	InnerVlan                 optional.Int
	SubscriberId              optional.Interface
	AccountingSessionId       optional.String
	SubscriberUserName        optional.String
	SubscriberUserNameMatches optional.String
	AgentRemoteId             optional.String
	AgentRemoteIdMatches      optional.String
	AgentCircuitId            optional.String
	AgentCircuitIdMatches     optional.String
	AccessType                optional.Interface
	Limit                     optional.Int
	Cursor                    optional.String
}

func (a *SubscriberApiService) GetSubscribers(ctx context.Context, localVarOptionals *SubscriberApiGetSubscribersOpts) ([]SubscriberSessionRef, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []SubscriberSessionRef
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IfpName.IsSet() {
		localVarQueryParams.Add("ifp_name", parameterToString(localVarOptionals.IfpName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IflName.IsSet() {
		localVarQueryParams.Add("ifl_name", parameterToString(localVarOptionals.IflName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OuterVlan.IsSet() {
		localVarQueryParams.Add("outer_vlan", parameterToString(localVarOptionals.OuterVlan.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AnpVlan.IsSet() {
		localVarQueryParams.Add("anp_vlan", parameterToString(localVarOptionals.AnpVlan.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InnerVlan.IsSet() {
		localVarQueryParams.Add("inner_vlan", parameterToString(localVarOptionals.InnerVlan.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubscriberId.IsSet() {
		localVarQueryParams.Add("subscriber_id", parameterToString(localVarOptionals.SubscriberId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccountingSessionId.IsSet() {
		localVarQueryParams.Add("accounting_session_id", parameterToString(localVarOptionals.AccountingSessionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubscriberUserName.IsSet() {
		localVarQueryParams.Add("subscriber_user_name", parameterToString(localVarOptionals.SubscriberUserName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubscriberUserNameMatches.IsSet() {
		localVarQueryParams.Add("subscriber_user_name_matches", parameterToString(localVarOptionals.SubscriberUserNameMatches.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AgentRemoteId.IsSet() {
		localVarQueryParams.Add("agent_remote_id", parameterToString(localVarOptionals.AgentRemoteId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AgentRemoteIdMatches.IsSet() {
		localVarQueryParams.Add("agent_remote_id_matches", parameterToString(localVarOptionals.AgentRemoteIdMatches.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AgentCircuitId.IsSet() {
		localVarQueryParams.Add("agent_circuit_id", parameterToString(localVarOptionals.AgentCircuitId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AgentCircuitIdMatches.IsSet() {
		localVarQueryParams.Add("agent_circuit_id_matches", parameterToString(localVarOptionals.AgentCircuitIdMatches.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccessType.IsSet() {
		localVarQueryParams.Add("access_type", parameterToString(localVarOptionals.AccessType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []SubscriberSessionRef
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SubscriberApiService Lists all test subscribers.
Reads all test subscriber objects from the Test AAA request table.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return []TestAaaObject
*/
func (a *SubscriberApiService) GetTestSubscribers(ctx context.Context) ([]TestAaaObject, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue []TestAaaObject
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/test-aaa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []TestAaaObject
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
SubscriberApiService Deletes a test subscriber.
Removes a test subscriber from the Test AAA request table.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param subscriberId The subscriber ID.
*/
func (a *SubscriberApiService) RemoveTestSubscriber(ctx context.Context, subscriberId int) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/test-aaa/{subscriber_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_id"+"}", fmt.Sprintf("%v", subscriberId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SubscriberApiService Adds or updates a test subscriber.
Injects a test subscriber into the Test AAA request table.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body Subscriber attributes.
  - @param subscriberId The subscriber ID.
*/
func (a *SubscriberApiService) StoreTestSubscriber(ctx context.Context, body TestAaaObject, subscriberId int) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/test-aaa/{subscriber_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_id"+"}", fmt.Sprintf("%v", subscriberId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SubscriberApiService Replaces all test subscribers.
Flushes the Test AAA request table and adds the test subscribers.
  - @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
  - @param body List of subscriber attribute objects.
*/
func (a *SubscriberApiService) StoreTestSubscribers(ctx context.Context, body []TestAaaObject) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/test-aaa"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
SubscriberApiService Dynamically update the specified subscriber.
Dynamically update the specified subscriber with settings such as  service profiles, QoS parameters, IGMP, and more. This API behaves  similarly to a RADIUS CoA request, where all attributes in a single  API call are processed together, just like in a single CoA message.  The behavior matches that of the corresponding CLI command.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subscriberId The subscriber ID.
 * @param optional nil or *SubscriberApiUpdateSubscriberOpts - Optional Parameters:
     * @param "Body" (optional.Interface of SubscriberUpdate) -  Subscriber attributes.

*/

type SubscriberApiUpdateSubscriberOpts struct {
	Body optional.Interface
}

func (a *SubscriberApiService) UpdateSubscriber(ctx context.Context, subscriberId int, localVarOptionals *SubscriberApiUpdateSubscriberOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribers/{subscriber_id}/update"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_id"+"}", fmt.Sprintf("%v", subscriberId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {

		localVarOptionalBody := localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
